<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        josyaaa
    </title>
    <meta name="description" content= okay!😯 hacking time >
    <meta name="keywords" content= Blog,Hexo,Theme,刘训灼,LiuXunzhuo >
    
<link rel="stylesheet" href="/josyaaa/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/josyaaa/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/josyaaa/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            云基础设施攻击方式逻辑
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>任何通过对云基础设施提供存储、计算、托管服务的场外服务平台的网络攻击都可以归结为云网络攻击，这可能包括利用 saas、iaas、pass、rassd等服务交付模型的服务平台的攻击。“信息收集(binaryedage and shodan)”</p>
<h1 id="cloud-computing-cyber-attacks"><a href="#cloud-computing-cyber-attacks" class="headerlink" title="cloud computing cyber attacks"></a>cloud computing cyber attacks</h1><ul>
<li>CSP and user：</li>
</ul>
<ol>
<li>配置错误，csp 提供不同层次的服务，主要是身份认证和权限控制</li>
<li>API 漏洞，csp 提供应用程序编程接口，允许其云计算服务进行交互工作，这些 API 包含大量文档… so API<br>的集成和配置中任何漏洞都可以攻击</li>
<li>恶意内部人员</li>
<li>远程协作</li>
</ol>
<ul>
<li>shell bot</li>
</ul>
<ol>
<li>暴力破解工具、辅助命令、控制方法以及在受感染的服务器上阻止其他加密矿工的附加功能</li>
<li>通过访问密钥获得访问权限</li>
</ol>
<h1 id="终端挖矿"><a href="#终端挖矿" class="headerlink" title="终端挖矿"></a>终端挖矿</h1><ul>
<li>cryptominer attack</li>
</ul>
<ol>
<li><p>一个名为的 shell 脚本tddwrt7s.sh下载到 &#x2F;dev&#x2F;shm 或 &#x2F;tmp。dota.tar.gz然后使用包含相同文件 ( ) 作为包含恶意软件有效负载的参数的七个不同 URL 执行 shell 脚本。该脚本随机选择其中一个 URL，然后下载有效负载，然后将其解压缩并执行。</p>
</li>
<li><p>该活动使用一系列脚本和可执行文件在目标系统上安装和持久化。第一个 shell 脚本（要么 要么initall）init2删除旧安装的恶意软件，然后运行脚本 init。这既安装了恶意软件组件，又通过逐步遍历一系列子文件夹（a、b、c）并覆盖 crontab 使它们在系统上持久存在。</p>
</li>
<li><p>CRYPTOMINER 杀手脚本,该恶意软件活动中更有趣的部分之一是它会检查系统上是否有其他加密矿工，如果有则阻止它们。如果它没有转身并在系统上安装自己的加密矿工，这通常被认为是一件好事。这是通过一个 272 行的 shell 脚本完成的，名为init0.</p>
</li>
<li><p>CRYPTOMINER 安装&#x2F;初始化,a加密矿工通过两个名为和的 shell 脚本进行初始化run。shell 脚本a创建一个名为upd并执行的新 shell 脚本，然后执行run. 然后该脚本分别运行名为andrun的 32 位或 64 位版本的加密矿工。还有一个名为的脚本用作终止开关。加密矿工连接到两个 MoneroHash IP（107.191.99.221 和 107.191.99.95）并开始挖矿</p>
</li>
</ol>
<ul>
<li>command and control</li>
</ul>
<ol>
<li><p>C2 安装&#x2F;初始化,命令和控制组件的初始化是通过也命名为a和的 shell 脚本完成的run。该脚本a创建名为sync执行的脚本run。这些脚本执行一个名为的打包 perl 脚本rsync和一个名为ps. perl 脚本rsync允许通过 IRC 进行命令和控制，并ps允许来自恶意基础设施的 SSH 连接，并将用户锁定在系统之外。还有一个名为stop.</p>
</li>
<li><p>C2 总结,命令和控制组件由文件rsync和ps. 该文件rsync是一个打包的 perl 脚本，它连接到充当 C2 基础设施的恶意 IRC 服务器。它允许预先配置的命令和直接的 shell 访问。文件 ps 可能用于通过删除受感染用户的.ssh文件夹并创建自己的文件夹来建立另一种持久性机制。</p>
</li>
</ol>
<ul>
<li>ssh</li>
</ul>
<ol>
<li><p>SSH 暴力破解器，与它的同胞一样，它依赖于一系列 shell 脚本来初始化。shell 脚本start由 init 脚本之一运行；然后它创建一个名为的新 shell 脚本aptitude，该脚本运行名为run. 然后run执行一个名为go.</p>
</li>
<li><p>shell 脚本go下载一个包含 IP 地址的文件，该文件名为xtr. 然后从文件中指定的 IP 下载IP 和密码列表（分别命名a和命名） 。这些文件被重命名为，然后传递给名为. 此命令启动暴力破解程序，该程序运行一段设定的时间，然后重新启动。较新的变体设置为运行 24 小时而不是 90 分钟</p>
</li>
</ol>
<blockquote>
<p>timeout 90m .&#x2F;tsm -t $threads -f 0 -s 10 -S 10 -p 0 p ip</p>
</blockquote>
<h1 id="容器挖矿"><a href="#容器挖矿" class="headerlink" title="容器挖矿"></a>容器挖矿</h1><p>容器是管理应用程序开发-部署生命周期的有用工具，但它们不是安全工具。 Docker 建立在主机操作系统的低级特性之上，这些特性定义了哪些进程可以互相看到，以及它们各自可以访问哪些计算资源。但是容器仍然在底层共享主机资源，而更高的堆栈复杂性可能来自操作员（或潜在的不良行为者）用于在运行时启动容器的权限和配置参数。<br>就像采用任何新工具一样，这是解决安全问题和快速行动之间的平衡行为。 Threat Stack Cloud Security Platform® 提供高保真安全信号，用于观察操作员在您的环境中运行的基础架构上的行为——来自主机服务器、容器、编排及其管理控制平面。除了我们的客户入职流程外，我们还以 Threat Stack Cloud SecOps ProgramSM 的形式提供持续服务，我们的安全运营中心 (SOC) 的分析师在该计划中代表客户对警报进行分类并调查安全事件。<br>威胁堆栈 SOC 为我们提供了对该领域趋势攻击的独特视角。我们越来越多地看到一个趋势是围绕加密劫持，并在下面的一组匿名对抗行为中进行了概述。</p>
<ol>
<li>识别易受远程代码注入攻击的网站<br>该命令通过应用程序层发送，通常通过操纵网站上的文本字段或网站 URL 中公开的 API 端点来发送恶意代码，或者通过探测代码参考网站上常见的嵌入式 shell 控制台来发送恶意代码。注入的代码过滤到操作系统，并在后端转换到容器环境。</li>
<li>启动容器，注入的代码在其中运行<br>后端启动容器并准备执行注入的代码。在 Threat Stack SOC 分析师观察到的最新趋势中，攻击者随后将命令直接传递到 Docker 容器内的 shell。虽然仅限于容器对主机操作系统的简化视图，但攻击者现在可以任意运行不受信任的代码</li>
<li>将加密货币可执行文件下载到本地文件系统<br>以下一系列事件都在几秒钟内发生，并由我们的 SOC 中的分析师近乎实时地监控。这些事务的速度表明脚本攻击与手动键盘方法相比。第一步是运行 wget 命令来下载加密挖矿可执行文件 CNRig。</li>
<li>修改权限，chmod +x<br>在这里，攻击者更改了 CNRig 可执行文件的权限，无需额外身份验证即可运行此文件。在通常设计为在微服务架构中作为不可变组件运行的容器中，此事件是一个强烈的信号，表明出现了问题，并且是威胁堆栈中警报的良好候选者。</li>
<li>在这种情况下，可执行文件用完了 &#x2F;tmp 目录。默认情况下，此行为将在威胁堆栈中触发警报，默认情况下从 &#x2F;tmp 中查找任何进程活动。恶意软件倾向于在 strsadHitioonasl Ltisnux 设置中运行，通常授予所有用户下载和执行的权限是活动 wouSldOtCrigagnearlTyhsrtesantoStitaficekd 客户。&#x2F;tmp 中的文件。但是，根据用例，客户在生产中运行 Docker 可能希望确保它们锁定 &#x2F;tmp 因为它们会危害网络中的其他主机。</li>
<li>CNrig 尝试出站网络连接 S3 或 RDS 等托管服务。所以每次之后新主机在网络上受到威胁，该过程尝试建立三个连接：两次尝试返回攻击者的加密矿池，参与者将检查其权限。和一个可能的 CDN。连接尝试没有重复，导致 SOC 分析师得出结论：由于网络层其他地方的保护措施（例如数据包过滤和防火墙。第4步客户通常会在 Threat Stack 之外部署网络防御措施来阻止此类活动。但是没有容器中运行的进程的上下文，以及操作系统中的用户行为登陆具有足够权限的主机在攻击进行时被捕获，因此可能需要数小时甚至数天的时间来探索日志、关联并从 RDS 中提取数据行为，并找出根本原因。在这些步骤中描述的研究确定了正在发生的事情之后，SOC 团队提醒客户。一旦在具有所需 IAM 权限的主机上</li>
</ol>
<h1 id="cloud-attack-pulic"><a href="#cloud-attack-pulic" class="headerlink" title="cloud attack pulic"></a>cloud attack pulic</h1><ol>
<li><p>在这种性质的攻击中，许多不良行为者采取的第一步是利用被盗的 API 密钥。被盗密钥是首选，因为它们的使用看起来是合法的，而且经常未被发现。为了获取这些密钥，攻击者使用了多种方法，包括使用恶意软件从员工笔记本电脑中窃取密钥，或者从 GitHub 等开源代码网站进行耕作，员工不小心上传了他们的 API 密钥。一旦参与者确认 API 密钥有效，他们希望确保他们可以重新获得访问权限，即使安全或运营中的某人终止了他们被盗的访问密钥。为此，他们可以创建新的密钥、IAM 角色，或使用另一种方法来创建持久化方法。</p>
</li>
<li><p>检查权限并尝试持续<br>一旦参与者通过基础设施 API 成功进入环境，他们就会查看自己是否可以直接访问所需的资源，例如 RDS 数据库或 S3 存储桶。除了尝试访问 S3 数据外，攻击者还将尝试启动一个 EC2 实例，以便它们可以在网络本身上持续存在。</p>
</li>
<li><p>利用不安全配置的 EC2<br>当他们发现他们无法直接访问 RDS 数据库或 S3 存储桶时，他们开始利用他们的 EC2 访问权限。在这种情况下，参与者在环境中启动 EC2 实例。由于环境中的安全组配置不佳，这些主机与其网络上的任何其他合法主机一样受信任。许多组织信任其网络边界内的所有流量，因此这使攻击者能够考虑横向移动。</p>
</li>
<li><p>登录到 EC2<br>在他们使用不安全的 IAM 角色策略识别或启动 EC2 实例后，他们会登录。攻击者现在已经在环境的网络中建立了一个滩头阵地，允许他们侦察和扫描他们已经破坏的网络。</p>
</li>
<li><p>横向移动跨主机<br>攻击者继续从这个初始的恶意 EC2 实例横向移动，扫描并利用它们危害网络中的其他主机。EC2 实例在启动时被授予 IAM 权限，这在某些情况下可以让它们合法访问 AWS 托管服务，如 S3 或 RDS。</p>
</li>
<li><p>登陆主机足够的权限并从 RDS 中提取数据，一旦参与者登陆具有必要 IAM 权限或主机上的数据库凭证的主机，参与者就可以执行必要的 RDS API 调用（或 SQL 命令）以使用目标数据访问数据库。从这里，他们可以直接通过终端或通过他们的受感染主机链将其泄露，以避免数据丢失防护工具。</p>
</li>
</ol>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2022 | Author: josyaaa | Theme by <a class="theme-author" href="https://github.com/josyaaa" style="font-size:14px; color: #969696">hacking</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/josyaaa/libs/jquery.min.js"></script>


<script src="/josyaaa/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/josyaaa/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>

    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
